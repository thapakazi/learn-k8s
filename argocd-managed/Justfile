# ArgoCD Multi-Cluster Setup with Kind

# Default workload clusters (space-separated)
workloads := "east west north south mars"

default:
    @just --list

# ─────────────────────────────────────────────────────────────
# Clusters
# ─────────────────────────────────────────────────────────────

# Create mgmt cluster
[group('clusters')]
cluster-mgmt:
    kind create cluster --config kind/kind-mgmt-cluster.yaml

# Create a workload cluster (e.g., just cluster east)
[group('clusters')]
cluster name:
    #!/usr/bin/env bash
    set -euo pipefail
    CONFIG="kind/kind-workload-{{name}}.yaml"
    if [[ ! -f "$CONFIG" ]]; then
        echo "Generating $CONFIG..."
        mkdir -p kind
        cat > "$CONFIG" <<EOF
    kind: Cluster
    apiVersion: kind.x-k8s.io/v1alpha4
    name: workload-{{name}}
    nodes:
    - role: control-plane
    networking:
      apiServerAddress: "0.0.0.0"
    EOF
    fi
    kind create cluster --config "$CONFIG"

# Create all workload clusters
[group('clusters')]
clusters-workloads:
    #!/usr/bin/env bash
    for c in {{workloads}}; do
        just cluster $c &
    done
    wait

# Create mgmt + all workload clusters
[group('clusters')]
clusters-create: cluster-mgmt clusters-workloads

# Delete a specific cluster (e.g., just cluster-delete east)
[group('clusters')]
cluster-delete name:
    kind delete cluster --name workload-{{name}} || true

# Delete mgmt cluster
[group('clusters')]
cluster-delete-mgmt:
    kind delete cluster --name mgmt || true

# Delete all clusters
[group('clusters')]
clusters-delete:
    #!/usr/bin/env bash
    kind delete cluster --name mgmt || true
    for c in {{workloads}}; do
        kind delete cluster --name workload-$c || true
    done

# Show all kubectl contexts
[group('clusters')]
contexts:
    kubectl config get-contexts

# ─────────────────────────────────────────────────────────────
# Networking
# ─────────────────────────────────────────────────────────────

# Setup docker network for all clusters
[group('network')]
network-setup:
    #!/usr/bin/env bash
    docker network create argo-kind || true
    docker network connect argo-kind mgmt-control-plane || true
    for c in {{workloads}}; do
        docker network connect argo-kind workload-$c-control-plane || true
    done

# Connect a specific cluster to the network
[group('network')]
network-connect name:
    docker network connect argo-kind workload-{{name}}-control-plane || true

# Remove docker network
[group('network')]
network-cleanup:
    docker network rm argo-kind || true

# ─────────────────────────────────────────────────────────────
# ArgoCD
# ─────────────────────────────────────────────────────────────

# Install ArgoCD on mgmt cluster
[group('argocd')]
argocd-install:
    kubectl config use-context kind-mgmt
    kubectl create namespace argocd || true
    kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
    kubectl wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd

# Get ArgoCD admin password
[group('argocd')]
argocd-password:
    @kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d && echo

# Port-forward ArgoCD server (runs in foreground)
[group('argocd')]
argocd-portfwd:
    kubectl port-forward svc/argocd-server -n argocd 6002:443

# Login to ArgoCD CLI
[group('argocd')]
argocd-login:
    #!/usr/bin/env bash
    ADMIN_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
    argocd login localhost:6002 --username admin --password "$ADMIN_PASSWORD" --insecure

# ─────────────────────────────────────────────────────────────
# Workload Cluster Setup
# ─────────────────────────────────────────────────────────────

# Setup argocd-manager on a workload cluster (e.g., just setup east)
[group('workloads')]
setup name:
    #!/usr/bin/env bash
    set -euo pipefail
    kubectl config use-context kind-workload-{{name}}
    kubectl create sa argocd-manager -n kube-system || true
    kubectl create clusterrolebinding argocd-manager-role \
      --clusterrole=cluster-admin \
      --serviceaccount=kube-system:argocd-manager || true
    # Create long-lived token secret
    kubectl apply -f - <<<'{"apiVersion":"v1","kind":"Secret","metadata":{"name":"argocd-manager-long-lived-token","namespace":"kube-system","annotations":{"kubernetes.io/service-account.name":"argocd-manager"}},"type":"kubernetes.io/service-account-token"}'
    # Wait for token to be populated
    echo "Waiting for token to be populated..."
    for i in {1..30}; do
      TOKEN=$(kubectl get secret argocd-manager-long-lived-token -n kube-system -o jsonpath='{.data.token}' 2>/dev/null || true)
      if [[ -n "$TOKEN" ]]; then
        echo "✓ argocd-manager configured on workload-{{name}}"
        exit 0
      fi
      sleep 1
    done
    echo "ERROR: Token not populated after 30s"
    exit 1

# Setup argocd-manager on all workload clusters
[group('workloads')]
setup-all-workloads:
    #!/usr/bin/env bash
    for c in {{workloads}}; do
        just setup $c
    done

# ─────────────────────────────────────────────────────────────
# ArgoCD Cluster Registration
# ─────────────────────────────────────────────────────────────

# Register a workload cluster with ArgoCD (e.g., just register east)
[group('argocd-clusters')]
register name:
    #!/usr/bin/env bash
    set -euo pipefail

    echo "Registering workload-{{name}} with ArgoCD..."

    # Ensure argocd-manager is setup
    just setup {{name}}

    # Use the docker hostname from argo-kind network
    SERVER="https://workload-{{name}}-control-plane:6443"

    # Get CA cert from the workload cluster (already base64 encoded)
    kubectl config use-context kind-workload-{{name}}
    CA_DATA=$(kubectl get secret argocd-manager-long-lived-token -n kube-system -o jsonpath='{.data.ca\.crt}')

    # Get the bearer token (decode it)
    TOKEN=$(kubectl get secret argocd-manager-long-lived-token -n kube-system -o jsonpath='{.data.token}' | base64 -d)

    # Validate we got the data
    if [[ -z "$CA_DATA" ]]; then
      echo "ERROR: Failed to get CA data"
      exit 1
    fi
    if [[ -z "$TOKEN" ]]; then
      echo "ERROR: Failed to get token"
      exit 1
    fi

    # Switch to mgmt cluster and create the cluster secret
    kubectl config use-context kind-mgmt

    # Build the config JSON
    CONFIG=$(printf '{"bearerToken":"%s","tlsClientConfig":{"insecure":false,"caData":"%s"}}' "$TOKEN" "$CA_DATA")

    # Create cluster secret
    kubectl create secret generic "cluster-workload-{{name}}" \
      --namespace argocd \
      --from-literal=name="workload-{{name}}" \
      --from-literal=server="$SERVER" \
      --from-literal=config="$CONFIG" \
      --dry-run=client -o yaml | \
      kubectl label --local -f - argocd.argoproj.io/secret-type=cluster --dry-run=client -o yaml | \
      kubectl apply -f -

    echo "✓ workload-{{name}} registered at ${SERVER}"

# Register all workload clusters with ArgoCD
[group('argocd-clusters')]
register-all:
    #!/usr/bin/env bash
    for c in {{workloads}}; do
        just register $c
    done

# Show registered ArgoCD clusters
[group('argocd-clusters')]
argocd-clusters:
    kubectl --context kind-mgmt get secrets -n argocd -l argocd.argoproj.io/secret-type=cluster

# ─────────────────────────────────────────────────────────────
# Apps
# ─────────────────────────────────────────────────────────────

# Deploy all apps from apps directory
[group('apps')]
apps-deploy:
    kubectl --context kind-mgmt apply -R -f apps/

# Deploy a specific app (e.g., just app-deploy guestbook)
[group('apps')]
app-deploy app:
    kubectl --context kind-mgmt apply -R -f apps/{{app}}/

# Remove all deployed apps
[group('apps')]
apps-delete:
    kubectl --context kind-mgmt delete -R -f apps/ || true

# Show ApplicationSets
[group('apps')]
apps-list:
    kubectl --context kind-mgmt get applicationsets -n argocd

# Show all ArgoCD Applications
[group('apps')]
apps-status:
    kubectl --context kind-mgmt get applications -n argocd

# ─────────────────────────────────────────────────────────────
# Full Workflows
# ─────────────────────────────────────────────────────────────

# Full setup: create clusters, network, install argocd, register workloads, and deploy apps
[group('workflows')]
setup-all: clusters-create network-setup argocd-install register-all apps-deploy

# Full cleanup: delete clusters and network
[group('workflows')]
cleanup: clusters-delete network-cleanup

# Add a new workload cluster (create, connect network, register with argocd)
[group('workflows')]
add name:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "Adding workload-{{name}}..."
    just cluster {{name}}
    just network-connect {{name}}
    just register {{name}}
    echo "✓ workload-{{name}} is ready"

# Remove a workload cluster (unregister from argocd, delete cluster)
[group('workflows')]
remove name:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "Removing workload-{{name}}..."
    kubectl --context kind-mgmt delete secret cluster-workload-{{name}} -n argocd || true
    kind delete cluster --name workload-{{name}} || true
    echo "✓ workload-{{name}} removed"
